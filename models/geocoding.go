// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Geocoding geocoding
//
// swagger:model Geocoding
type Geocoding struct {

	// The confidence that the address was correctly geocoded. Range 0-100. 100 was an exact record match, 0 is a wild guess.
	// Example: 90
	// Required: true
	// Maximum: 100
	// Minimum: 0
	Confidence *int64 `json:"confidence"`

	// The result object containing the latitude and longitude.
	Coordinate *GCSCoordinate `json:"coordinate,omitempty"`

	// Whether the original data source requires citation via their license terms. This is not used at the moment, but will be in the future.
	// Example: false
	// Required: true
	DatasetCitationRequired *bool `json:"dataset_citation_required"`

	// The address that was matched. This may be different from the input record when the record match was not an exact record match.
	// Required: true
	MatchedAddress *USAddress `json:"matched_address"`

	// The dataset that the result was derived from.
	// Example: US Census TIGER 2020
	// Required: true
	ResultDataset *string `json:"result_dataset"`

	// The description of where the point is. At the moment, all of the points are offset from the road, but in the future this will additionally include rooftop and entrance locations.
	// Example: offset
	// Required: true
	ResultLocation *string `json:"result_location"`

	// Describes how the location was derived. All geocodings are interpolated at the moment, but in the future this will include direct lookups.
	// Example: interpolated
	// Required: true
	ResultType *string `json:"result_type"`
}

// Validate validates this geocoding
func (m *Geocoding) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConfidence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCoordinate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDatasetCitationRequired(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMatchedAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResultDataset(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResultLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResultType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Geocoding) validateConfidence(formats strfmt.Registry) error {

	if err := validate.Required("confidence", "body", m.Confidence); err != nil {
		return err
	}

	if err := validate.MinimumInt("confidence", "body", *m.Confidence, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("confidence", "body", *m.Confidence, 100, false); err != nil {
		return err
	}

	return nil
}

func (m *Geocoding) validateCoordinate(formats strfmt.Registry) error {
	if swag.IsZero(m.Coordinate) { // not required
		return nil
	}

	if m.Coordinate != nil {
		if err := m.Coordinate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("coordinate")
			}
			return err
		}
	}

	return nil
}

func (m *Geocoding) validateDatasetCitationRequired(formats strfmt.Registry) error {

	if err := validate.Required("dataset_citation_required", "body", m.DatasetCitationRequired); err != nil {
		return err
	}

	return nil
}

func (m *Geocoding) validateMatchedAddress(formats strfmt.Registry) error {

	if err := validate.Required("matched_address", "body", m.MatchedAddress); err != nil {
		return err
	}

	if m.MatchedAddress != nil {
		if err := m.MatchedAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("matched_address")
			}
			return err
		}
	}

	return nil
}

func (m *Geocoding) validateResultDataset(formats strfmt.Registry) error {

	if err := validate.Required("result_dataset", "body", m.ResultDataset); err != nil {
		return err
	}

	return nil
}

func (m *Geocoding) validateResultLocation(formats strfmt.Registry) error {

	if err := validate.Required("result_location", "body", m.ResultLocation); err != nil {
		return err
	}

	return nil
}

func (m *Geocoding) validateResultType(formats strfmt.Registry) error {

	if err := validate.Required("result_type", "body", m.ResultType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this geocoding based on the context it is used
func (m *Geocoding) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCoordinate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMatchedAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Geocoding) contextValidateCoordinate(ctx context.Context, formats strfmt.Registry) error {

	if m.Coordinate != nil {
		if err := m.Coordinate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("coordinate")
			}
			return err
		}
	}

	return nil
}

func (m *Geocoding) contextValidateMatchedAddress(ctx context.Context, formats strfmt.Registry) error {

	if m.MatchedAddress != nil {
		if err := m.MatchedAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("matched_address")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Geocoding) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Geocoding) UnmarshalBinary(b []byte) error {
	var res Geocoding
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
