// Code generated by go-swagger; DO NOT EDIT.

package zip_code

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new zip code API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for zip code API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	V1AddressReverseZIPCode(params *V1AddressReverseZIPCodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*V1AddressReverseZIPCodeOK, error)

	V1AddressZIPCode(params *V1AddressZIPCodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*V1AddressZIPCodeOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  V1AddressReverseZIPCode converts a coordinate to a ZIP code

  **Description**<br>

Look up a single ZIP Code from the given latitude and longitude.

This performs a lookup based on US Census "ZIP Code Tabulation Areas." These areas are calculated
by the US Census based on the most common ZIP Codes within different US Census blocks. This is necessary
because in practice, ZIP Codes are not defined by areas but are defined as collections of addresses.
They correspond loosely to areas, but not exactly. To get an accurate ZIP Code for an address, see
the geocoding endpoints.

For more information on ZIP Code tabulation areas and why ZIP Codes cannot be accurately represented
by areas, [click here](https://geo.codes/resources/articles/complete-guide-to-zip-codes#what-are-zip-code-tabulation-areas).

They have the following limitations:
- ZIP Code Tabulation Areas do not have full coverage of the land mass of the United States. This
only matters in remote areas without deliverable addresses; in practice this is fine.
In these cases, the API will return the	closest tabulation area unless the ` + "`strict`" + `
parameter is provided.
- Addresses within a ZIP Code Tabulation Area might have different ZIP Codes. Geocoding an address
is the only way to get a perfect ZIP Code.
- The PlusFour field on the return value will always be empty.

**Lookup cost**<br>

This query requires an account. Please sign up at https://geo.codes/signup and get your API
key at https://geo.codes/account/api

One query counts as one lookup. It only costs a query if it returns data. If you have exceeded
your account quota, the request will not succeed.
*/
func (a *Client) V1AddressReverseZIPCode(params *V1AddressReverseZIPCodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*V1AddressReverseZIPCodeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewV1AddressReverseZIPCodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "v1-address-reverse-zip-code",
		Method:             "GET",
		PathPattern:        "/v1/address/reverse_zip_code",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &V1AddressReverseZIPCodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*V1AddressReverseZIPCodeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for v1-address-reverse-zip-code: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  V1AddressZIPCode converts a ZIP code to a coordinate

  **Description**<br>

Convert a single ZIP Code into a latitude and longitude.

By default, this returns a point that is guaranteed to be interior to the given ZIP Code. It may
not necessarily be the centroid, because the centroid of some ZIP Codes do not fall within their
borders (imagine a ZIP Code that is shaped like a crescent).

If a Plus-4 ZIP code is passed, only the first 5 digits will be used (i.e. the +4 will be ignored).

This performs a lookup based on US Census "ZIP Code Tabulation Areas." These areas are calculated
by the US Census based on the most common ZIP Codes within different US Census blocks. This is necessary
because in practice, ZIP Codes are not defined by areas but are defined as collections of addresses.
They correspond loosely to areas, but not exactly. To get an accurate ZIP Code for an address, see
the geocoding endpoints.

For more information on ZIP Code tabulation areas and why ZIP Codes cannot be accurately represented
by areas, [click here](https://geo.codes/resources/articles/complete-guide-to-zip-codes#what-are-zip-code-tabulation-areas).
*/
func (a *Client) V1AddressZIPCode(params *V1AddressZIPCodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*V1AddressZIPCodeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewV1AddressZIPCodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "v1-address-zip-code",
		Method:             "GET",
		PathPattern:        "/v1/address/zip_code",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &V1AddressZIPCodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*V1AddressZIPCodeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for v1-address-zip-code: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
